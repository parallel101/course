[Script Info]
Title: 现代C++中的高性能并行编程与优化
ScriptType: v4.00+
PlayResX: 1920
PlayResY: 1080
Original Script: woclass

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,微软雅黑,80,&H00FFFFFF,&H0000FFFF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2.0,1,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:05.25,0:00:11.33,Default,,0,0,0,,大家好，今天来给大家介绍的是 CMake 入门
Dialogue: 0,0:00:12.26,0:00:16.13,Default,,0,0,0,,首先来介绍一下我们的课程
Dialogue: 0,0:00:17.29,0:00:21.04,Default,,0,0,0,,我们是分为前半段和后半段
Dialogue: 0,0:00:21.98,0:00:25.63,Default,,0,0,0,,前半段是介绍 C++ 的
Dialogue: 0,0:00:25.96,0:00:29.84,Default,,0,0,0,,后半段是介绍并行和优化的
Dialogue: 0,0:00:30.49,0:00:32.65,Default,,0,0,0,,我看看B站能不能...
Dialogue: 0,0:00:34.11,0:00:35.54,Default,,0,0,0,,B站能看到
Dialogue: 0,0:00:38.72,0:00:46.12,Default,,0,0,0,,我们的硬件要求是64位，还有二核四线程
Dialogue: 0,0:00:46.38,0:00:48.55,Default,,0,0,0,,为什么要四线程呢？
Dialogue: 0,0:00:49.46,0:00:51.27,Default,,0,0,0,,之后你就知道了
Dialogue: 0,0:00:52.35,0:00:56.14,Default,,0,0,0,,我们还会提到 GPU
Dialogue: 0,0:00:56.49,0:01:01.25,Default,,0,0,0,,我们用的是 CUDA，所以需要英伟达显卡
Dialogue: 0,0:01:02.42,0:01:04.82,Default,,0,0,0,,软件的话可以看到
Dialogue: 0,0:01:05.08,0:01:09.47,Default,,0,0,0,,我们在 Windows 上需要的是 VS2019
Dialogue: 0,0:01:09.84,0:01:13.77,Default,,0,0,0,,但是我们要的不一定就是它的 IDE
Dialogue: 0,0:01:14.06,0:01:21.45,Default,,0,0,0,,我们只是要它内置的一个编译器而已
Dialogue: 0,0:01:22.36,0:01:26.24,Default,,0,0,0,,它的编译器和 IDE 是捆绑安装的
Dialogue: 0,0:01:26.42,0:01:31.37,Default,,0,0,0,,你也可以用别的编辑器或者 IDE 都可以的
Dialogue: 0,0:01:34.84,0:01:36.87,Default,,0,0,0,,介绍一下我自己
Dialogue: 0,0:01:37.60,0:01:40.75,Default,,0,0,0,,我是这个太极编译器
Dialogue: 0,0:01:41.17,0:01:45.90,Default,,0,0,0,,它其实是用 C++ 写的一个 Python 包
Dialogue: 0,0:01:49.46,0:01:54.04,Default,,0,0,0,,他可以用 Python 的语法写出来的函数
Dialogue: 0,0:01:54.31,0:01:58.24,Default,,0,0,0,,它能够编译然后在 GPU 上运行
Dialogue: 0,0:01:58.57,0:02:03.38,Default,,0,0,0,,它能支持 CUDA、OpenGL 之类的后端
Dialogue: 0,0:02:08.53,0:02:12.54,Default,,0,0,0,,你可以看到我是他的贡献者嘛
Dialogue: 0,0:02:14.71,0:02:17.81,Default,,0,0,0,,这个是体积渲染
Dialogue: 0,0:02:17.84,0:02:20.28,Default,,0,0,0,,还有这个烟雾的仿真
Dialogue: 0,0:02:20.92,0:02:24.76,Default,,0,0,0,,这个是有一点 PBR 贴图在里面
Dialogue: 0,0:02:25.10,0:02:28.55,Default,,0,0,0,,这个是一个分型的那个图案
Dialogue: 0,0:02:28.83,0:02:30.80,Default,,0,0,0,,这是多体引力
Dialogue: 0,0:02:32.49,0:02:36.53,Default,,0,0,0,,我还是会做 Blender 插件的
Dialogue: 0,0:02:36.92,0:02:40.46,Default,,0,0,0,,我把太极集成到了Blender 里
Dialogue: 0,0:02:40.69,0:02:43.77,Default,,0,0,0,,就变成了我们的 taichi_blend
Dialogue: 0,0:02:45.18,0:02:48.61,Default,,0,0,0,,首先他可以做基于物理的动画
Dialogue: 0,0:02:49.64,0:02:53.48,Default,,0,0,0,,他这是代表水在上面滴出来
Dialogue: 0,0:02:53.77,0:02:56.69,Default,,0,0,0,,然后出现了波纹的情况
Dialogue: 0,0:02:57.58,0:03:00.99,Default,,0,0,0,,这是我用 Blender 创建的场景
Dialogue: 0,0:03:01.30,0:03:06.84,Default,,0,0,0,,然后用 taichi_blend 内置的渲染器渲染出来的结果
Dialogue: 0,0:03:08.41,0:03:11.17,Default,,0,0,0,,这是视窗里显示的结果
Dialogue: 0,0:03:11.54,0:03:14.07,Default,,0,0,0,,可以看到这是一个方的灯
Dialogue: 0,0:03:14.87,0:03:17.15,Default,,0,0,0,,照着这个康奈尔的箱子
Dialogue: 0,0:03:18.77,0:03:20.78,Default,,0,0,0,,他还是有一点噪音
Dialogue: 0,0:03:20.80,0:03:23.10,Default,,0,0,0,,但是他收敛的很快
Dialogue: 0,0:03:25.00,0:03:29.77,Default,,0,0,0,,我目前是在开发 Zeno 节点仿真
Dialogue: 0,0:03:30.64,0:03:32.31,Default,,0,0,0,,它主要的目的
Dialogue: 0,0:03:33.24,0:03:38.04,Default,,0,0,0,,让用户可以通过连节点的方式来编程
Dialogue: 0,0:03:38.79,0:03:42.74,Default,,0,0,0,,实现各种各样的算法，并且可视化
Dialogue: 0,0:03:43.02,0:03:49.46,Default,,0,0,0,,如这是通过这个猪头变成一个史莱姆的材料
Dialogue: 0,0:03:50.17,0:03:53.03,Default,,0,0,0,,根据它的受力情况来上色
Dialogue: 0,0:03:53.32,0:03:56.28,Default,,0,0,0,,它这里其实是有一个地面
Dialogue: 0,0:03:56.30,0:03:57.82,Default,,0,0,0,,然后它砸到地面上
Dialogue: 0,0:03:58.14,0:04:03.19,Default,,0,0,0,,它代表受力了，它就会变颜色
Dialogue: 0,0:04:03.75,0:04:06.84,Default,,0,0,0,,这是根据流体的速度来着色
Dialogue: 0,0:04:07.13,0:04:11.11,Default,,0,0,0,,这是我们...代表这里是留下来的是水
Dialogue: 0,0:04:11.81,0:04:14.86,Default,,0,0,0,,然后把这个固体给冲散了
Dialogue: 0,0:04:15.59,0:04:18.77,Default,,0,0,0,,这些也是我们用这个框架
Dialogue: 0,0:04:18.79,0:04:21.27,Default,,0,0,0,,开发出来的各种算法
Dialogue: 0,0:04:23.39,0:04:26.98,Default,,0,0,0,,这是我们把 Zeno 集成到了 Blender 里
Dialogue: 0,0:04:27.24,0:04:31.84,Default,,0,0,0,,所做出来的一个动画的某一帧的截图
Dialogue: 0,0:04:34.21,0:04:36.12,Default,,0,0,0,,看看有没有弹幕
Dialogue: 0,0:04:37.52,0:04:41.88,Default,,0,0,0,,啊，左上角的弹幕要关了吗？
Dialogue: 0,0:04:42.20,0:04:43.08,Default,,0,0,0,,这个吗？
Dialogue: 0,0:04:46.99,0:04:50.16,Default,,0,0,0,,那那我要把它关了是吗？
Dialogue: 0,0:04:52.20,0:04:53.66,Default,,0,0,0,,那我关了
Dialogue: 0,0:04:56.43,0:04:57.26,Default,,0,0,0,,关了？
Dialogue: 0,0:05:00.04,0:05:01.70,Default,,0,0,0,,那那我关了
Dialogue: 0,0:05:03.43,0:05:08.33,Default,,0,0,0,,今天的介绍是是关于编译器
Dialogue: 0,0:05:08.55,0:05:10.97,Default,,0,0,0,,因为要讲 CMake
Dialogue: 0,0:05:11.18,0:05:15.65,Default,,0,0,0,,CMake 就是用来编译一个程序的
Dialogue: 0,0:05:17.56,0:05:20.16,Default,,0,0,0,,他到底要做什么呢？
Dialogue: 0,0:05:20.29,0:05:22.04,Default,,0,0,0,,他的目的就是
Dialogue: 0,0:05:22.30,0:05:28.49,Default,,0,0,0,,把一个 cpp 原文件编译成这个可执行文件
Dialogue: 0,0:05:31.49,0:05:34.49,Default,,0,0,0,,这个编译器还分很多种
Dialogue: 0,0:05:35.43,0:05:40.91,Default,,0,0,0,,目前主流的是 Linux 上的 GNU 系列
Dialogue: 0,0:05:41.28,0:05:46.02,Default,,0,0,0,,还有 LLVM 家生产的 Clang 系列
Dialogue: 0,0:05:46.87,0:05:54.75,Default,,0,0,0,,还有思维软件生产的MSVC系列，然后他们各自对应的命令行程序如下
Dialogue: 0,0:05:54.75,0:06:03.98,Default,,0,0,0,,然后我们这里因为要编译 C++ ，所以就不是用的GCC，而是 g++ 了
Dialogue: 0,0:06:03.98,0:06:07.99,Default,,0,0,0,,这样它会链接一些 C++ 类库
Dialogue: 0,0:06:08.39,0:06:19.39,Default,,0,0,0,,如果用GCC编译命令CPP的话，它到时候链接的时候会说找不到那个 C++ 的什么
Dialogue: 0,0:06:19.72,0:06:27.21,Default,,0,0,0,,那关了好多了吧
Dialogue: 0,0:06:27.21,0:06:32.11,Default,,0,0,0,,然后我们编译完之后就可以运行
Dialogue: 0,0:06:32.11,0:06:35.61,Default,,0,0,0,,就是我这里是有案例
Dialogue: 0,0:06:36.77,0:06:48.35,Default,,0,0,0,,首先我们用 g++ V点CTP杠O a.out，然后然后就可以看到生成 a.out
Dialogue: 0,0:06:48.35,0:07:05.71,Default,,0,0,0,,然后我们另一点cpp也是这里面有一个 printf ，然后顺便说一下，就是 C++ 的CSTDIO和C语言的STDIO有什么区别呢？
Dialogue: 0,0:07:06.65,0:07:11.98,Default,,0,0,0,,就是C语言它只会提供这个，但不会提供这个
Dialogue: 0,0:07:11.98,0:07:20.68,Default,,0,0,0,,如果我们用 C++ 的话，它前面就有一个STD前缀也可以用，就这点区别
Dialogue: 0,0:07:21.01,0:07:46.66,Default,,0,0,0,,然后我们还可以去看一看生成这个 a.out 它里面到底是什么呀，我们可以搜索一下，可以看到它这里面就是一个幂函数，然后幂函数可以看到它进来，先是做了一些压站
Dialogue: 0,0:07:46.66,0:08:05.93,Default,,0,0,0,,然后它调用了 puts 即使 printf 它最后也会被优化成 puts 因为我没有格式化嘛，所以它就变成 puts 这个 printf hello  puts hello world，然后这个 puts 又是什么呢？
Dialogue: 0,0:08:05.93,0:08:14.96,Default,,0,0,0,,可以看到port s 的，它只是跳转到了某一个地址，然后这个地址又是什么呢？
Dialogue: 0,0:08:14.96,0:08:23.70,Default,,0,0,0,,它其实是一个相对地址，而这个地址这个函数定义的位置其实是在
Dialogue: 0,0:08:28.76,0:08:45.37,Default,,0,0,0,,可以看到他的电影位置，其实在这个文件里，你看他其实是在这个软件里实现的
Dialogue: 0,0:08:45.37,0:08:49.68,Default,,0,0,0,,那他们为什么能够相互之间调用呢？
Dialogue: 0,0:08:50.01,0:09:00.78,Default,,0,0,0,,就因为它在编译的时候啊，它会自动链接上 libc 所以它可以调用到 libc 里的那个函
Dialogue: 0,0:09:01.23,0:09:05.00,Default,,0,0,0,,这就是动态链接库
Dialogue: 0,0:09:07.00,0:09:20.12,Default,,0,0,0,,对呀，这里面是汇编语言，这是一个把那个就是编译器不是生成机器码嘛
Dialogue: 0,0:09:20.12,0:09:31.59,Default,,0,0,0,,然后OBJdump 这个程序，它可以把机器码反汇编成那个汇编语言就可以看得懂了
Dialogue: 0,0:09:31.59,0:09:39.36,Default,,0,0,0,,然后less 是让它可以上下滚动，不加less 的我就难以滚动了
Dialogue: 0,0:09:39.36,0:09:51.58,Default,,0,0,0,,然后就是我们刚才只用了一个hello 文件，但有时候我们是需要多个文件的
Dialogue: 0,0:09:51.58,0:10:05.10,Default,,0,0,0,,这时候我们其实其实是可以根据hello.cpp V.cpp a.out 也是可以的
Dialogue: 0,0:10:05.61,0:10:15.85,Default,,0,0,0,,但是这样的话他就有一个问题，就是比如我们改了一下hello world ，把它变成below word
Dialogue: 0,0:10:15.85,0:10:24.69,Default,,0,0,0,,然后他这时候去编的话，就得全部重新编一遍，他就浪费了时间，对吧？
Dialogue: 0,0:10:24.69,0:10:43.85,Default,,0,0,0,,所以说这种情况我们可以把先把hello world 变成hello 点O当然要加一个杠C选项，表示只是暂时编译成O文件，不是 a.out 的可执行文件
Dialogue: 0,0:10:43.85,0:10:53.85,Default,,0,0,0,,这个O呢其实里面也是已经变成汇编了，不过他不是可执行的
Dialogue: 0,0:10:54.53,0:10:59.11,Default,,0,0,0,,如果我这样的话，他就会报错
Dialogue: 0,0:10:59.11,0:11:09.60,Default,,0,0,0,,可以的，就是要用那个操作系统的int 80中断
Dialogue: 0,0:11:09.60,0:11:18.94,Default,,0,0,0,,即使lab c 里面这个这个实现打印，就是通过调用inter 80这个中断的
Dialogue: 0,0:11:18.94,0:11:38.32,Default,,0,0,0,,然后然后就是我们这样以后的话，然后这样以后就只需要把这两个一编译好的点O文件把它编译成 a.out 就行了
Dialogue: 0,0:11:38.32,0:11:58.69,Default,,0,0,0,,然后这时候我们就算去改了，hello world 把它改了一下代码，我们也只需要就就重复这一次编译，就不需要把命也重新编译遍了，从而能够节省时间
Dialogue: 0,0:11:59.55,0:12:21.37,Default,,0,0,0,,哪个问题啊，你说啥你有问过问题吗？
Dialogue: 0,0:12:24.16,0:12:25.47,Default,,0,0,0,,快啊
Dialogue: 0,0:12:27.07,0:12:39.57,Default,,0,0,0,,然后然后就是我们已经可以把它分离的编译了，这样的话我们改一个文件，就只需要编译一次
Dialogue: 0,0:12:39.57,0:12:49.83,Default,,0,0,0,,然后就是你会发现，如果我们需要知道哦，我改了这个文件，我得重新运行一下
Dialogue: 0,0:12:49.83,0:13:01.06,Default,,0,0,0,,这个命令就是他他就非常麻烦你还得记住你改了哪个，不然的话就得全部重新编译
Dialogue: 0,0:13:01.06,0:13:09.40,Default,,0,0,0,,所以说GNU还有unix 他们发明了make 这个软件，，它的功能就是
Dialogue: 0,0:13:16.10,0:13:21.93,Default,,0,0,0,,它的功能就是你可以只写一个那个依赖关系的链
Dialogue: 0,0:13:21.93,0:13:27.48,Default,,0,0,0,,就是我说 a.out 是依赖这两个OB结尾这样的
Dialogue: 0,0:13:27.48,0:13:36.09,Default,,0,0,0,,然后这个OBJ它又依赖于CPP文件，这个OBJ又依赖于这个 cpp 文件
Dialogue: 0,0:13:36.09,0:13:37.76,Default,,0,0,0,,这样的话就是
Dialogue: 0,0:13:43.53,0:13:56.37,Default,,0,0,0,,然后我输入make 可以看到他执行了这些操作，然后我再输入mac，他说哎你没有改过任何一个文件呀
Dialogue: 0,0:13:56.37,0:14:01.46,Default,,0,0,0,,他说已经up to date，也就是说我不需要再编译了
Dialogue: 0,0:14:02.20,0:14:11.42,Default,,0,0,0,,然后这时候我如果改动一下hello world，这时再make 他就知道哦，我只需要编译一下
Dialogue: 0,0:14:11.42,0:14:20.31,Default,,0,0,0,,hello, 只有他被改变了，而并没有被改变，所以他只编译hello 就节省了时间
Dialogue: 0,0:14:24.27,0:14:30.24,Default,,0,0,0,,然后然后再那个他也会没反应
Dialogue: 0,0:14:30.24,0:14:32.08,Default,,0,0,0,,然后
Dialogue: 0,0:14:41.75,0:15:03.81,Default,,0,0,0,,然后就是他还可以用通配符，但是他的缺点就是他只是在unix 上是默认安装的，但windows 上用起来就还要去下载很多的模拟环境了什么的就很麻烦
Dialogue: 0,0:15:03.81,0:15:15.88,Default,,0,0,0,,然后他还需要自己去指定这个O依赖CPP，O依赖CPP哪个O依赖型，然后怎么编译
Dialogue: 0,0:15:15.88,0:15:22.65,Default,,0,0,0,,但是它的问题就是我有时候有头文件，比如命依赖了
Dialogue: 0,0:15:22.65,0:15:31.57,Default,,0,0,0,,hello.h 那我如果在命cpp里 include ，我还得改一下， Makefile 就就比较麻烦
Dialogue: 0,0:15:31.57,0:15:41.11,Default,,0,0,0,,然后它的语法呢也和那个那种特定语言一样，它不像需要可以做很多判断
Dialogue: 0,0:15:41.11,0:15:47.26,Default,,0,0,0,,就比如我需要仅在windows 操作系统上构建 a.out
Dialogue: 0,0:15:47.26,0:15:54.03,Default,,0,0,0,,如果我在linux 上就把它改名为 b.out ，这个就比较困难
Dialogue: 0,0:15:54.36,0:16:03.93,Default,,0,0,0,,然后不同编译器的flag 也不同，比如GCC是杠C然后微软它是怎么回事？
Dialogue: 0,0:16:03.93,0:16:09.61,Default,,0,0,0,,就是你知道GCC要开变异的优化，它是这样的
Dialogue: 0,0:16:09.61,0:16:15.17,Default,,0,0,0,,然后微软它是它是要用这个杠的，对吧？
Dialogue: 0,0:16:16.47,0:16:30.37,Default,,0,0,0,,然后就是为了能够应对这种不同平台之间的差异啊，然后就有了 CMake 它的功能就是首先它是跨平台的
Dialogue: 0,0:16:30.37,0:16:36.19,Default,,0,0,0,,就就刚才不是有这四个坏处嘛，它一一解决
Dialogue: 0,0:16:36.19,0:16:42.98,Default,,0,0,0,,首先它只需要写一份seem make lesson ，这和 Makefile 是一样的
Dialogue: 0,0:16:42.98,0:16:48.80,Default,,0,0,0,,然后它能够在调用的时候自动是怎么说呢？
Dialogue: 0,0:16:50.62,0:17:04.75,Default,,0,0,0,,就是可以看到我们这里有一个similar list ，然后我们这里是添加了一个可执行文件，然后它是做什么呢？
Dialogue: 0,0:17:04.75,0:17:06.94,Default,,0,0,0,,它的神奇之处来了
Dialogue: 0,0:17:06.94,0:17:15.44,Default,,0,0,0,,可以看到我们先指定c make 杠1buildbuild 就代表他要输出这个make 文件的目录
Dialogue: 0,0:17:15.44,0:17:27.78,Default,,0,0,0,,然后一看可以看到他这个他说啊我已经把构建文件输送到标的里了，然后我们看一下标的里有什么看到吗？
Dialogue: 0,0:17:27.78,0:17:32.60,Default,,0,0,0,,就是一个make a file ，然后 Makefile 里有啥呢？
Dialogue: 0,0:17:32.60,0:17:48.97,Default,,0,0,0,,是自动指定的这个编译规则，比如命.cpp 啊，命点S啊，它都能自动帮你搞定啊，而且你也不需要关心头文件怎么样
Dialogue: 0,0:17:52.27,0:18:05.98,Default,,0,0,0,,我也知道啊，哦不，我是大三，然后你在这个目录里再make 就可以看到 a.out 了
Dialogue: 0,0:18:05.98,0:18:20.66,Default,,0,0,0,,然后这时候执行它也是一样的，只不过它similar 能够帮你跨平台，你在windows 上就就它能帮你生成这样一个文件
Dialogue: 0,0:18:20.66,0:18:24.90,Default,,0,0,0,,它能生成hello 点VCpro 健康的
Dialogue: 0,0:18:24.90,0:18:43.50,Default,,0,0,0,,然后他生成这个以后，你就打开用VS2019打开这个VCproject, 然后你点运行，它就能自动编译，然后也生成这个 a.out 就很智能，对吧？
Dialogue: 0,0:18:48.05,0:19:13.52,Default,,0,0,0,,然后这个依赖关系呢不用说了，它能够自动去检测你是 cpp ，你导入了哪些头文件，然后它也会自动体现在 Makefile 里，它还会帮你说明哎呀，这是哪一个目标，然后依赖了谁呀？
Dialogue: 0,0:19:13.52,0:19:21.06,Default,,0,0,0,,这这这样子有什么问题吗？
Dialogue: 0,0:19:26.22,0:19:44.12,Default,,0,0,0,,然后 CMake 的语法它有很多那个F判断了什么的，然后他还能configure 或者安装，也就是说比如make install，还有内置的函数
Dialogue: 0,0:19:44.12,0:19:49.16,Default,,0,0,0,,帮你做，你不需要自己去写copy 命令
Dialogue: 0,0:19:49.16,0:20:15.42,Default,,0,0,0,,然后他还能检测编译器，比如这个比如这个 CMake 钢笔build，然后钢笔c max CXcompile 等于C类加加，这样我们就可以指定让C让他用C链加加作为这个编译器
Dialogue: 0,0:20:15.42,0:20:20.41,Default,,0,0,0,,然后我们再去调用mac
Dialogue: 0,0:20:29.45,0:20:34.87,Default,,0,0,0,,然后就可以看到他这个里面种子
Dialogue: 0,0:20:39.91,0:20:44.15,Default,,0,0,0,,总之他就是调用了C量编译器，对吧？
Dialogue: 0,0:20:44.15,0:20:51.23,Default,,0,0,0,,你看这样它就可以调用C量变一起，而不是默认的极加加了
Dialogue: 0,0:20:51.23,0:21:02.80,Default,,0,0,0,,就是它可以指定要使用的C量编译器，然后还可以指定还可以指定 C++ 的版本
Dialogue: 0,0:21:02.80,0:21:11.70,Default,,0,0,0,,比如 C++ 17或者11什么的啊？
Dialogue: 0,0:21:11.70,0:21:23.68,Default,,0,0,0,,哦没问题啦，然后他还能指定一些flag，通过一种类似控的方式
Dialogue: 0,0:21:24.89,0:21:34.74,Default,,0,0,0,,这里已经说过了，就是它也是能够就是它相当于一个红，就是它是构建系统的
Dialogue: 0,0:21:34.74,0:21:50.87,Default,,0,0,0,,构建系统，就是它构建系统的构建系统生成一个构建系统能用的文件，然后构建系统能用的文件再去调用编译器变成可执行文件
Dialogue: 0,0:21:50.87,0:22:03.04,Default,,0,0,0,,然后就是做到了库，就是我们刚刚是使用了hello 和命这两个文件，但这两个文件都是我们的
Dialogue: 0,0:22:03.04,0:22:11.48,Default,,0,0,0,,如果我们要把这个hello 作为酷给别人用呢，这时候就得需要用到酷吧
Dialogue: 0,0:22:12.10,0:22:17.83,Default,,0,0,0,,然后库呢它又分为这个静态库和动态库
Dialogue: 0,0:22:17.83,0:22:28.97,Default,,0,0,0,,就是它静态库的话其实和我们刚刚这个直接作为点O文件的链接没什么两样
Dialogue: 0,0:22:28.97,0:22:45.86,Default,,0,0,0,,你可以认为这个LIB这个静态库他就是一个多个点O文件的打包，也就是它相当于一个ZIP之类的归档这种
Dialogue: 0,0:22:48.46,0:23:00.29,Default,,0,0,0,,然后其实这样的话，就导致他可能只能给你自己用，就很难给别人用，甚至是共享的去用
Dialogue: 0,0:23:00.29,0:23:06.53,Default,,0,0,0,,就比如我有 a.out，我有 b.out，他们都用到了
Dialogue: 0,0:23:06.53,0:23:08.18,Default,,0,0,0,,hello 这个函数
Dialogue: 0,0:23:08.18,0:23:21.40,Default,,0,0,0,,那如果作为lab 的话，他就会把hello 这个代码重复在 a.out 和 b.out 里生成两份，这不就浪费了吗？
Dialogue: 0,0:23:21.40,0:23:29.61,Default,,0,0,0,,所以说后来又发明了这个动态链接库，在windows 上以DOL为后缀
Dialogue: 0,0:23:29.61,0:23:49.70,Default,,0,0,0,,他们只要把这些DOL放到EXE的同一个目录下，这个EXE啊就可以在运行时自动查找到它这个僵硬的DLL，然后读取里面的函数，然后就可以调用了
Dialogue: 0,0:23:50.57,0:24:00.15,Default,,0,0,0,,这样的话我只需要一个hello 点DOL，而 a.out 和 b.out 里只有hello 函数的一个插桩
Dialogue: 0,0:24:00.15,0:24:02.98,Default,,0,0,0,,就是我刚才不是看到了
Dialogue: 0,0:24:10.15,0:24:28.85,Default,,0,0,0,,对对对对对，就是刚才好像是看到了这个对方，他可以进行一个跳转，这个其实就是一个插桩函数，它跳到哪里呢？
Dialogue: 0,0:24:28.85,0:24:38.76,Default,,0,0,0,,它跳到的 libc 点SO里，其中SO就是linux 上的运行词动态链接库的后缀名
Dialogue: 0,0:24:38.76,0:24:47.39,Default,,0,0,0,,然后它就不需要把整个 puts 放在这里了，就可以节省空间和内存
Dialogue: 0,0:24:48.15,0:25:12.52,Default,,0,0,0,,所以就是可以看到很多的程序，就比如我们的LS杠，LLS这个程序它也是链接了 libc 作为这个通用的库，它里面也会调用C语言的一些东西，然后就实现了这个代码的共享
Dialogue: 0,0:25:12.52,0:25:18.30,Default,,0,0,0,,对的对的，这个lab 为什么需要呢？
Dialogue: 0,0:25:18.30,0:25:34.27,Default,,0,0,0,,因为lab 里他放了这些插桩函数，就是他你在链接的时候只需要链接这个很小的lab，然后你调用hello 其实是先进lab 的这个插桩函数
Dialogue: 0,0:25:34.27,0:25:38.49,Default,,0,0,0,,插桩在运行时查找跳转到这个调
Dialogue: 0,0:25:39.26,0:25:48.14,Default,,0,0,0,,然后他就是但是他的时间是在店里，所以他的这个空间就解释什么呢？
Dialogue: 0,0:25:50.30,0:25:58.96,Default,,0,0,0,,然后windows 的这个你要查找顺序，是先查找同目录，然后再查找pass 变量
Dialogue: 0,0:25:58.96,0:26:07.94,Default,,0,0,0,,然后linux 呢是有r pass，就是可以指定每一个文件都从哪一个目录里去找
Dialogue: 0,0:26:07.94,0:26:22.90,Default,,0,0,0,,然后如果找不到再找默认的就是用这个lab 这些，有一点不一样，就是SO它是没有配套的点A的
Dialogue: 0,0:26:22.90,0:26:38.83,Default,,0,0,0,,但DOL是有配套的点lab 就是有一个特色就是windows 和linux 实现动态库的方式是很不一样的
Dialogue: 0,0:26:38.83,0:26:49.71,Default,,0,0,0,,就是linux 里是没有这个与SO配套的点A的，，它会自动生成插桩
Dialogue: 0,0:26:50.47,0:26:58.66,Default,,0,0,0,,然后就是我们提到 CMake 中要怎么去创建动态和静态库呢？
Dialogue: 0,0:26:58.66,0:27:01.39,Default,,0,0,0,,你就用ad library 命令
Dialogue: 0,0:27:10.93,0:27:37.90,Default,,0,0,0,,可以看到我们这里稍微改了一下，就是把它变成一个hello lab 这个静态库，然后我们调用一下，然后再去看看build 里有什么可以看到他先生成lab ，hello lab 点A，然后 a.out 又生成，这个还有静态链接了
Dialogue: 0,0:27:37.90,0:27:43.65,Default,,0,0,0,,hello lam , 我们可以用LDE看看它有没有链接
Dialogue: 0,0:27:43.65,0:27:52.84,Default,,0,0,0,,C它没有链接C他他只是链接了，本来就有的那些，而没有出现点A为什么呢？
Dialogue: 0,0:27:52.84,0:28:03.73,Default,,0,0,0,,这就是静态库的好处，它不需要运行时查找，所以你删了这个文件删了，然后再运行，它还是能用
Dialogue: 0,0:28:03.73,0:28:11.61,Default,,0,0,0,,但是如果你用动态库的话，我们这里改成下的，然后重新标0
Dialogue: 0,0:28:14.05,0:28:35.91,Default,,0,0,0,,可以看到这里是生成了一个动态库点SO然后我们再找找看 a.out 链接了，谁可以看到它链接了当前目录下的hello love 点SO也就是说它这个 a.out 你是没有hello 的实现的，它是用了这个里面
Dialogue: 0,0:28:35.91,0:28:46.65,Default,,0,0,0,,因为这个里面我们可以OB婕dump 杠TA点orn，可以看到它的hello 也是一个PLT
Dialogue: 0,0:28:46.65,0:28:53.70,Default,,0,0,0,,PLT就是插桩函数，它是跳转到一个其他文件里的地址的
Dialogue: 0,0:28:53.70,0:29:00.47,Default,,0,0,0,,然后如果我们把lab hello 这个删了呢，然后再运行它就会报错
Dialogue: 0,0:29:00.47,0:29:11.19,Default,,0,0,0,,这就是动态库的缺点，它必须在运行时能在同目录或者系统目录找到这个文件，它才能运行
Dialogue: 0,0:29:17.68,0:29:24.21,Default,,0,0,0,,然后然后如果是静态库的话
Dialogue: 0,0:29:30.61,0:29:44.22,Default,,0,0,0,,静态库的话，我们再看一下它的反汇编，，可以看到它是直接把实线放到这个 a.out 里
Dialogue: 0,0:29:44.55,0:29:50.40,Default,,0,0,0,,就是他不需要动态查找了，但是他会变大
Dialogue: 0,0:29:51.19,0:30:13.24,Default,,0,0,0,,然后windows 环境下这个库呢还需要一些，比如DOXpod 之类的命令，所以就很困难，就不推荐在windows 下自己用，不用想库
Dialogue: 0,0:30:13.24,0:30:24.42,Default,,0,0,0,,但是别人提供的库呢，因为要照顾很多人一起使用的情况，就大多都是动态库
Dialogue: 0,0:30:24.42,0:30:41.28,Default,,0,0,0,,然后就是就是我们刚才不是创建了 a.out 用了hello lab 嘛，我们就用了这个target link library 来链接一个酷的 a.out 上
Dialogue: 0,0:30:41.28,0:30:44.44,Default,,0,0,0,,然后pop leg 是啥意思呢？
Dialogue: 0,0:30:44.44,0:31:00.77,Default,,0,0,0,,之后我也告诉你，就是 CMake 里有很多这种全大写的，就是一个目标，后面一个全大写的，这全大写就是为了防止和你的文件名混淆
Dialogue: 0,0:31:00.77,0:31:08.41,Default,,0,0,0,,它是一个类似于关键字的存在，，它可以指定某些选项之类的
Dialogue: 0,0:31:10.27,0:31:22.95,Default,,0,0,0,,然后为什么也就是我们刚才编写的这个命.cpp ，不管是不是库，它都需要一个声明，这是什么原因呢？
Dialogue: 0,0:31:25.35,0:31:33.92,Default,,0,0,0,,然后然后就是这是因为 C++ 是一种依赖上下文的语言
Dialogue: 0,0:31:33.92,0:31:43.21,Default,,0,0,0,,就是如果我hello 这里不写的话，编译器怎么知道它是一个函数还是一个类名
Dialogue: 0,0:31:43.21,0:31:46.51,Default,,0,0,0,,就你知道我可以定义class
Dialogue: 0,0:31:46.51,0:31:55.07,Default,,0,0,0,,hello, 然后这个hello 就会被解释成创建一个hello lay 的实例，对吧？
Dialogue: 0,0:31:55.07,0:32:10.56,Default,,0,0,0,,因为同样是括号嘛，然后他就没法分辨了，然后他也不知道返回值是Y的还是什么类型，所以编译器是需要知道hello 是什么，是函数吗？
Dialogue: 0,0:32:10.56,0:32:11.38,Default,,0,0,0,,是类吗？
Dialogue: 0,0:32:11.38,0:32:17.14,Default,,0,0,0,,它的参数类型是什么，返回值类型是什么都要知道
Dialogue: 0,0:32:20.62,0:32:38.26,Default,,0,0,0,,然后我举一个很极端的例子，就swift 小于my class 大于A就是如果你熟悉 C++ 的话，应该会把它看成list of my class，也就是由my class 类组成的数组
Dialogue: 0,0:32:38.26,0:32:51.57,Default,,0,0,0,,但是如果你没有include victor 的话，他不知道victor 是一个类的模板，他也不知道这个小三角号代表什么意思
Dialogue: 0,0:32:51.57,0:33:12.38,Default,,0,0,0,,他他有可能把它解释成一个小，就是victor 小于my class，然后my class 也不是类名了，是一个变量名，然后变量名又大于另一个A他就搞不懂了，然后就会出现一些很离奇的错误
Dialogue: 0,0:33:12.38,0:33:21.43,Default,,0,0,0,,为了避免这种离奇的错误，我们经常会写出这种代码，就是type name 修饰符丢失
Dialogue: 0,0:33:21.43,0:33:32.07,Default,,0,0,0,,比如T这里是不知道是什么的，然后点K是一个模板，然后点K加了一个T不知道是什么类型的类型
Dialogue: 0,0:33:32.07,0:33:38.14,Default,,0,0,0,,然后他得出的这个碳粉，他也不知道是一个类还是一个词
Dialogue: 0,0:33:38.14,0:33:42.45,Default,,0,0,0,,如果我们后面直接加个X的话，它就出错
Dialogue: 0,0:33:42.45,0:33:54.43,Default,,0,0,0,,因为它不知道type 是不是类型，所以通过type of name 修饰，就让编译器确定它右边这个表达式是一个类型
Dialogue: 0,0:33:54.43,0:33:56.60,Default,,0,0,0,,不要搞错成值了
Dialogue: 0,0:33:56.60,0:34:01.80,Default,,0,0,0,,有什么问题吗？
Dialogue: 0,0:34:08.03,0:34:09.87,Default,,0,0,0,,没问题吗？
Dialogue: 0,0:34:10.25,0:34:12.12,Default,,0,0,0,,那继续了
Dialogue: 0,0:34:12.71,0:34:16.55,Default,,0,0,0,,然后所以说声明是很重要的
Dialogue: 0,0:34:16.55,0:34:27.78,Default,,0,0,0,,然后 C++ 就经常有这种分离声明和定义的习惯，这是声明这是定义，声明引用定义
Dialogue: 0,0:34:27.78,0:34:32.26,Default,,0,0,0,,然后使用者查看到的是这个胜利
Dialogue: 0,0:34:32.26,0:34:36.68,Default,,0,0,0,,然后头文件是怎么回事呢？
Dialogue: 0,0:34:36.68,0:34:43.48,Default,,0,0,0,,就是如果我们二个.cpp 要用hello 命令.cpp 也要用
Dialogue: 0,0:34:43.48,0:34:55.36,Default,,0,0,0,,hello, 他们的声明是一模一样的，但为了使用hello 腔声明很多遍就是他hello 肯定是被多个函数使用的嘛
Dialogue: 0,0:34:55.36,0:35:01.01,Default,,0,0,0,,然后我们每个文件都要写一遍声明就麻烦了
Dialogue: 0,0:35:01.79,0:35:21.38,Default,,0,0,0,,然后就有人开始想，哎，能不能想办法，就我这个只需要写一遍，然后让某种工具自动把自动把这个hello 插到这个位置呢，然后就真的有这么一个程序，它叫做预处理器
Dialogue: 0,0:35:21.71,0:35:33.17,Default,,0,0,0,,就是你在这两个cpp里标写一个记号，也就是我们的include 记号，然后引号里写文件名
Dialogue: 0,0:35:33.17,0:35:48.44,Default,,0,0,0,,这个文件名在预处理器看来，他看到这里就会把它替换为halo.h 里的这个内容，然后替换为这这个以后他就可以继续顺畅的编译了
Dialogue: 0,0:35:49.59,0:36:02.13,Default,,0,0,0,,然后通过这个头文件的方式，就 C++ 又实现类似于当前高级语言中的那个模块的那种形式
Dialogue: 0,0:36:03.96,0:36:14.07,Default,,0,0,0,,然后他就是然后这个这个还有一个什么好处呢？
Dialogue: 0,0:36:14.07,0:36:23.03,Default,,0,0,0,,就是之前我这里如果还漏加了一个int 参数，那我得全部改变，可能还改漏了一个
Dialogue: 0,0:36:23.03,0:36:29.82,Default,,0,0,0,,而这样呢我只要改了一个，我就能确定他们全部都会被改掉
Dialogue: 0,0:36:29.82,0:36:33.62,Default,,0,0,0,,然后如果我改漏了，他肯定会出错
Dialogue: 0,0:36:33.62,0:36:38.24,Default,,0,0,0,,然后建议在hello CPP顶上也引cloud 一下
Dialogue: 0,0:36:38.24,0:36:50.66,Default,,0,0,0,,hello 点，这样的话，我hello 被改写的时候，我这个时限也得被改写，不然他会出错，就不用受这种沉默的错误
Dialogue: 0,0:36:51.40,0:37:02.82,Default,,0,0,0,,就然后现在这个预处理器已经被变成编译器的一部分了
Dialogue: 0,0:37:02.82,0:37:11.37,Default,,0,0,0,,以前我们是通过不需要不需要这个回这个问题问的
Dialogue: 0,0:37:11.37,0:37:23.28,Default,,0,0,0,,好，我给你看一个，你去看一下这文件啊没有吗？
Dialogue: 0,0:37:24.74,0:37:31.03,Default,,0,0,0,,总之就是总之总之总之
Dialogue: 0,0:37:36.29,0:37:45.65,Default,,0,0,0,,就是你可以看到所有的C语言头文件里，它都多了这么一个东西，这是为什么呢？
Dialogue: 0,0:37:45.65,0:38:01.93,Default,,0,0,0,,它就是因为 C++ 它有存在，即使然后为了能够在这个C语言的语境下，不要用存在就是C语言的作者他都会在里面写这么一段话
Dialogue: 0,0:38:01.93,0:38:23.24,Default,,0,0,0,,也就是说C语言的程序员在给 C++ 打工，也就是他看到如果你当前是 C++ 编译器，它会把你添加一个这个，然后这个括号里面开始的函数啊类型它都会以C语言去解析
Dialogue: 0,0:38:23.24,0:38:38.90,Default,,0,0,0,,也就是说如果你C语言去引入一个C的头文件，他是它是由C语言这个头文件的作者负责去处理这个判断是不是孙佳佳
Dialogue: 0,0:38:38.90,0:38:46.09,Default,,0,0,0,,如果是的话，我就说明我是一个C语言的头文件哦，不要搞错了
Dialogue: 0,0:38:47.02,0:38:49.64,Default,,0,0,0,,这个的区别待会儿再说
Dialogue: 0,0:38:51.34,0:39:02.43,Default,,0,0,0,,这个的区别就是为什么CSTDIO四个监控号还还有四个引号呢？
Dialogue: 0,0:39:02.43,0:39:08.19,Default,,0,0,0,,因为引号它代表就是优先搜索当前目录
Dialogue: 0,0:39:09.73,0:39:19.41,Default,,0,0,0,,可以看到我们这个hello.h 就是在当前目录的
Dialogue: 0,0:39:19.41,0:39:28.84,Default,,0,0,0,,如果我们在命里面声明为正儿，他就会说找不到这个文件，为什么呢？
Dialogue: 0,0:39:28.84,0:39:39.04,Default,,0,0,0,,因为他如果用监控号，他默认会在user 杠include 里去找它，这个里面是没有这些文件的
Dialogue: 0,0:39:39.04,0:39:53.04,Default,,0,0,0,,这里面只有系统自带的文件，所以要使用当前目录下的文件就必须要用引号，或者这样也可以或者这样也可以
Dialogue: 0,0:39:53.53,0:40:06.99,Default,,0,0,0,,然后还有一个特点，就是你用尖括号的地方也可以用引号，用间括号的地方可以用引号
Dialogue: 0,0:40:06.99,0:40:10.18,Default,,0,0,0,,但是用引号的地方不能用间括号
Dialogue: 0,0:40:10.18,0:40:18.17,Default,,0,0,0,,所以如果你编译别人的程序出现这个这头文件找不到，你可以试试看把它换成引号
Dialogue: 0,0:40:18.55,0:40:22.58,Default,,0,0,0,,但是为什么有了引号还要加括号呢？
Dialogue: 0,0:40:22.58,0:40:25.27,Default,,0,0,0,,就是为了出现这种情况
Dialogue: 0,0:40:27.91,0:40:38.91,Default,,0,0,0,,就是如果我在当前文件夹有一个垃圾，CSTDIO我随便乱写了一个文件，那它也能够正常编译
Dialogue: 0,0:40:38.91,0:40:47.07,Default,,0,0,0,,但是如果你用这个方式引入的话，它会优先查找当前目录下，他就说错了
Dialogue: 0,0:40:47.07,0:40:51.53,Default,,0,0,0,,因为我这个文件我是乱写的，对吧？
Dialogue: 0,0:40:51.53,0:41:09.11,Default,,0,0,0,,你甚至可以说就是你甚至可以引入一个similar list，当然它会出错，所以它其实不会检查你文件的后缀名什么的，完全靠你自己
Dialogue: 0,0:41:10.54,0:41:16.24,Default,,0,0,0,,所以说监控号就保证不会把当前目录的东西给引入了
Dialogue: 0,0:41:16.88,0:41:33.95,Default,,0,0,0,,然后当前这个呢就是还有一个问题，就是有时候头文件会递归的引用，就是比如我们 C++ 不是有类吗？
Dialogue: 0,0:41:35.81,0:41:39.89,Default,,0,0,0,,然后类也是定义在这个头文件里的
Dialogue: 0,0:41:40.22,0:41:48.77,Default,,0,0,0,,然后我如果我一个函数用到了某个类，那这个类也必须被导入，对吧？
Dialogue: 0,0:41:48.77,0:41:53.47,Default,,0,0,0,,这很符合直觉，然后这个东西就会被预处理成
Dialogue: 0,0:41:53.47,0:42:03.87,Default,,0,0,0,,首先他要看到这个标记，他先打开这个文件来读，然后这个文件你又用一个这个标题，这个文件也展开
Dialogue: 0,0:42:03.87,0:42:13.03,Default,,0,0,0,,然后最后展开完以后就变成这个形式了，这个形式才是最终输入到 C++ 编译器的形式
Dialogue: 0,0:42:15.82,0:42:29.69,Default,,0,0,0,,但是这样有一个很严重的问题啊，就是递归引用中的菱形引用就是我有两个函数，一个叫hello，一个叫goodbye
Dialogue: 0,0:42:29.69,0:42:37.28,Default,,0,0,0,,我想用hello 函数，也想用goodbye 函数，然后hello 和goodbye 都用到了my
Dialogue: 0,0:42:37.78,0:42:50.74,Default,,0,0,0,,然后这个my class 呢它就导致它会被重复导入两遍，然后就会出现这种错误，这怎么办呢？
Dialogue: 0,0:42:50.74,0:43:04.90,Default,,0,0,0,,就是我们有一个有两种方法，然后就是就是可以加上一个这个programming once 就保证这个头文件只被引用一次
Dialogue: 0,0:43:04.90,0:43:14.03,Default,,0,0,0,,然后还有一种更复杂的方式，就是先点饭，一个红点泛my class.h Sincluded
Dialogue: 0,0:43:14.03,0:43:26.93,Default,,0,0,0,,然后就检测如果它有没有被定义，如果没有，那就定义这个michael 如果定义了，那我就直接跳转到这里
Dialogue: 0,0:43:26.93,0:43:41.70,Default,,0,0,0,,FN的F就要把它整个全部包起来，就保证它不会被重复引入，那是这样的问题，就是你得每次去写FF就很烦
Dialogue: 0,0:43:41.70,0:43:49.73,Default,,0,0,0,,所以现在的编译器一般都支持pro 光猫ones，就加一行，这个就可以了
Dialogue: 0,0:43:51.20,0:44:00.93,Default,,0,0,0,,然后复杂的工程中常常是有子模块的，像这样
Dialogue: 0,0:44:01.64,0:44:04.45,Default,,0,0,0,,然后我们现在把这个
Dialogue: 0,0:44:09.69,0:44:15.71,Default,,0,0,0,,可以看到我们这里把hello 移到了子模块
Dialogue: 0,0:44:15.71,0:44:27.87,Default,,0,0,0,,子模块有一个构建规则，这是我们主目录的构建规则，这是我们子目录的构建规则
Dialogue: 0,0:44:27.87,0:44:33.96,Default,,0,0,0,,子目录里面有这个hello lamp，从这个hello CPP生成
Dialogue: 0,0:44:33.96,0:44:47.20,Default,,0,0,0,,然后主目录呢有从命生成 a.out 这种，然后我们只需要add some directly，就可以把这个引用到这里
Dialogue: 0,0:44:47.20,0:45:01.31,Default,,0,0,0,,然后它的目录是那个路径呢，它是相对路径，就是你不需要在hello lamp 杠，hello, 它自动会从当前目录往下找就很方便
Dialogue: 0,0:45:01.31,0:45:07.57,Default,,0,0,0,,然后我们这里也可以引用它生成的这个库完全没问题
Dialogue: 0,0:45:13.98,0:45:18.83,Default,,0,0,0,,然后子目录呢，就是我们刚才说的头文件
Dialogue: 0,0:45:18.83,0:45:24.23,Default,,0,0,0,,然后这个头文件因为型号只能导入当前目录的
Dialogue: 0,0:45:24.23,0:45:31.25,Default,,0,0,0,,然后这个问题就出来了，就是我的命必须把这个路径也得改了
Dialogue: 0,0:45:31.25,0:45:33.41,Default,,0,0,0,,因为是当前目录嘛
Dialogue: 0,0:45:33.41,0:45:39.82,Default,,0,0,0,,如果我哋在一个子文件夹，我还得这样寻找上一个文
Dialogue: 0,0:45:39.82,0:45:55.99,Default,,0,0,0,,这个代表上一个文件就他就麻烦了，就得找头文件，然后我们就可以用这个include directory 来把hello lab 文件夹当成它的头文件搜索目录
Dialogue: 0,0:45:55.99,0:46:02.17,Default,,0,0,0,,然后我们include hello.h 的时候，就会从hello level 里去找
Dialogue: 0,0:46:02.17,0:46:06.29,Default,,0,0,0,,然后我们甚至可以换成间括号了
Dialogue: 0,0:46:06.29,0:46:19.11,Default,,0,0,0,,因为include directory，他认为你就是系统头文件夹，从而可以用尖括号喝口水，有什么问题吗？
Dialogue: 0,0:46:24.80,0:46:35.41,Default,,0,0,0,,没问题，然后我们这个就不需要自己去写明路径了，它就可以变成一个间括号的
Dialogue: 0,0:46:35.41,0:46:51.61,Default,,0,0,0,,hello , ，但是这样还有一个问题啊，就是我们链接这个孔之后还得再指定一遍他这个头文件目录就很烦了，就don't repeat yourself 嘛
Dialogue: 0,0:46:51.61,0:46:57.28,Default,,0,0,0,,他这就违背这个不要重复做一件事的准则了
Dialogue: 0,0:46:57.61,0:47:11.38,Default,,0,0,0,,然后其实可以这样，就我们把这个库的定义，它这个地方加一个include directory public ，就是点代表当前目录
Dialogue: 0,0:47:11.38,0:47:20.48,Default,,0,0,0,,也就是说我只需要我只需要这个这个库，它有这个头文件
Dialogue: 0,0:47:20.48,0:47:27.98,Default,,0,0,0,,那引用这个库的adding out 也会被自动加上这个头文件目录
Dialogue: 0,0:47:27.98,0:47:41.19,Default,,0,0,0,,然后就是他这个public 就是体现在这里，就是如果我们的hello lab 定义了点，而且是power link 的
Dialogue: 0,0:47:41.19,0:47:52.78,Default,,0,0,0,,那么它这个引用它的地方也是会被传播传染，就是类似于传染上这个hello lab 的这个点目录了
Dialogue: 0,0:47:53.22,0:48:01.83,Default,,0,0,0,,然后如果不想传播的话，就改成private ，这就是这两个开关的作用
Dialogue: 0,0:48:01.83,0:48:12.59,Default,,0,0,0,,public 会传播private 就是我只有hello level 有这个目录，我引用我的人就看不到人，知道了吧？
Dialogue: 0,0:48:13.08,0:48:52.00,Default,,0,0,0,,PPT我给你看这个路径，plus 6101靠点开这个点开这个，然后点download 就可以了，行吧，add include 你是说待会儿跟你说，然后就是除了我们可以指定头文件目录，还有指定链接的库，我们还有这么多这么多命令
Dialogue: 0,0:48:52.63,0:49:03.20,Default,,0,0,0,,首先是刚刚说到的，它可以指定头文件目录，然后link libraries 它可以指定我要链接哪个库
Dialogue: 0,0:49:03.20,0:49:19.02,Default,,0,0,0,,然后at 点fashion 这个功能就是定义一个红它的这个功能就和define microsoft 一一样是一样的，明白吗？
Dialogue: 0,0:49:19.02,0:49:25.99,Default,,0,0,0,,然后如果你只是写michael 没有等于一的话，就是一个空的红
Dialogue: 0,0:49:25.99,0:49:34.70,Default,,0,0,0,,然后这个前面加个杠迪，他是为了符合某些人的习惯，加了和不加是完全等价的
Dialogue: 0,0:49:34.70,0:49:43.15,Default,,0,0,0,,然后这个FOMP这个flag 你想要加到我们 cpp 上，你也可以用compare options 啊
Dialogue: 0,0:49:43.73,0:49:56.43,Default,,0,0,0,,就它会变成极加加杠f open MP，然后算一下是什么样给的，就是它能够自动把它加上
Dialogue: 0,0:49:56.43,0:50:08.48,Default,,0,0,0,,然后public 呢就代表链接了买 cpp 的人啊，也会享受到这个flag ，这也是private ，private 也是有用的
Dialogue: 0,0:50:10.62,0:50:17.73,Default,,0,0,0,,对呀对呀，games 和我们不一样
Dialogue: 0,0:50:17.73,0:50:27.31,Default,,0,0,0,,虽然我这个有点，你看八个6101就是对标games ，games 是游戏从1到1
Dialogue: 0,0:50:27.31,0:50:41.19,Default,,0,0,0,,然后我这个是判断量，我说的是你要从零到一的去做这个并行编程，而不一定是游戏里的编程，知道吧？
Dialogue: 0,0:50:42.01,0:50:50.26,Default,,0,0,0,,怎么没了，然后这个和下面这堆看起来更短的命令什么区别呢？
Dialogue: 0,0:50:50.26,0:50:55.62,Default,,0,0,0,,我先说就是不推荐使用它有一个什么问题呢？
Dialogue: 0,0:50:55.62,0:51:09.83,Default,,0,0,0,,就是它一旦这个指定了之后，它会把后面定义的所有这个可执行文件和库全部加上这个头文件目录它全部会加上
Dialogue: 0,0:51:09.83,0:51:13.89,Default,,0,0,0,,不管你有没有链接什么，它全加上了
Dialogue: 0,0:51:13.89,0:51:22.30,Default,,0,0,0,,然后这个是库的搜索路径，它和这个是不对标的，就是这两个是不能互补的
Dialogue: 0,0:51:22.30,0:51:41.87,Default,,0,0,0,,它是指定搜索路径，它是指定链接哪个库你不能说就是我给接下来所有的那个目标都链接一个库不行，你也不能指定单个目标，他要去哪个目录里搜索也不行，就是这两个是不能对标的
Dialogue: 0,0:51:42.57,0:51:50.40,Default,,0,0,0,,然后这个是把红定义加到接下来的每一个每一个目每一个那个目标上
Dialogue: 0,0:51:50.40,0:52:06.93,Default,,0,0,0,,也就是说它相当于把接下来每一个都调用了一下这个然后我们windows 有一个问题，就是就是他需要定义一个normal max
Dialogue: 0,0:52:07.52,0:52:24.46,Default,,0,0,0,,被坑过的人自然知道这是什么，然后你就可以用and defence 把它加到你文件的头部，然后你就不用再搜windows.h 里那个命和max 的骚扰了，就很方便
Dialogue: 0,0:52:25.30,0:52:36.88,Default,,0,0,0,,上一个就是他只能指定到这个目标要在哪搜索，这个就是全部目标都会在这里搜索，知道吧？
Dialogue: 0,0:52:37.43,0:52:50.38,Default,,0,0,0,,糯米max 被坑过吧，然后这个也是给所有的目标都加一个FONMP，然后我们就要涉及到第三方了
Dialogue: 0,0:52:50.38,0:53:10.31,Default,,0,0,0,,刚刚我们说的这个handle lab 是我们自己的库，有时候我们是要用别人的库，然后别人的库呢它又分为三种形式，一种是纯头文件，一种是可以作为模块，一种是必须要去系统里预安装
Dialogue: 0,0:53:10.31,0:53:14.90,Default,,0,0,0,,然后我们最简单的一种就是全头文件库
Dialogue: 0,0:53:15.24,0:53:34.13,Default,,0,0,0,,我给你看一个最最最最经典的头文件库，nothing . 哎呀，就是在很多图形学的教材里都会用到这个STBimage
Dialogue: 0,0:53:34.13,0:53:56.39,Default,,0,0,0,,其实它就是这这个这个仓库里其中一个一个一个库，然后它就是有很多很多这样的纸层，它可以去打印一个字符串，可以去写入文件，可以编辑声音啊，以及可以加载字体
Dialogue: 0,0:53:56.39,0:54:02.11,Default,,0,0,0,,它有很多功能，只需要一个头文件就很方便
Dialogue: 0,0:54:02.11,0:54:13.33,Default,,0,0,0,,但是用它的时候有一个需要，就是你需要定义一下这个他就他为什么要有这个设计呢？
Dialogue: 0,0:54:13.33,0:54:26.29,Default,,0,0,0,,就是他为了防止重复定义，就是如果你在多个地方使用了STBin man ，他这里面的函数就会被定义多面，这是他们不想看到的
Dialogue: 0,0:54:27.34,0:54:38.08,Default,,0,0,0,,所以呢就可以通过定义这个红，你只需要在一个用它的文件里定义一下这个，然后之后就都可以用了
Dialogue: 0,0:54:38.08,0:54:41.13,Default,,0,0,0,,有问题吗？
Dialogue: 0,0:54:41.46,0:54:51.56,Default,,0,0,0,,无法解析的外部符号，你肯定是没有链接，就是你需要链接这个库才能用它
Dialogue: 0,0:54:51.93,0:54:58.66,Default,,0,0,0,,你定义一下这个它就能链接上这个，对吧？
Dialogue: 0,0:55:01.45,0:55:12.16,Default,,0,0,0,,我的PPG呢，然后这是大名鼎鼎STB，然后还有magic animal ，这个也很好用
Dialogue: 0,0:55:12.16,0:55:15.07,Default,,0,0,0,,它有一个什么特点呢？
Dialogue: 0,0:55:15.07,0:55:24.94,Default,,0,0,0,,它的一个特点就是它可以实现枚举类的自反射
Dialogue: 0,0:55:24.94,0:55:35.14,Default,,0,0,0,,也就是如果你有一个枚举类，它能够知道这个枚举是什么名字的，给你看一个例子
Dialogue: 0,0:55:37.61,0:55:55.56,Default,,0,0,0,,比如这个color ，它有红、绿蓝，然后它可以通过magic animal animal name 把它变成一个字符串，就是red ，它会变成一个字符串的red
Dialogue: 0,0:55:55.91,0:56:03.34,Default,,0,0,0,,这个其实实现原理还蛮神奇的，感兴趣可以去看一看这个头文件
Dialogue: 0,0:56:03.34,0:56:17.93,Default,,0,0,0,,然后头文件库的使用方法呢就以zeno 为例，它直接就只需要把它放到我们这个头include 文件夹里，然后再用我们的那个include directory
Dialogue: 0,0:56:17.93,0:56:28.94,Default,,0,0,0,,就是我刚刚说不推荐使用的这个include directory ，然后里面放了我们这些成头文件的库就可以用了
Dialogue: 0,0:56:29.77,0:56:32.21,Default,,0,0,0,,我是怎么用的？
Dialogue: 0,0:56:33.75,0:56:39.78,Default,,0,0,0,,无所谓，总之呢他就只需要你能找到这个头文件就能用了
Dialogue: 0,0:56:40.47,0:56:47.97,Default,,0,0,0,,然后GOM它有两种模式，一种是纯头文件，一种也是作为子模块
Dialogue: 0,0:56:47.97,0:56:52.14,Default,,0,0,0,,作为子模块的话，编译速度会快一点
Dialogue: 0,0:56:52.14,0:56:57.43,Default,,0,0,0,,如果搞不定子模块，用成头文件也没什么问题
Dialogue: 0,0:56:58.66,0:57:06.46,Default,,0,0,0,,你需要一个科学上网
Dialogue: 0,0:57:07.69,0:57:20.24,Default,,0,0,0,,然后这个repeat jason 呢，它是一个jason 解析的库，这个库很神奇，就在于它甚至不用STD里面的类
Dialogue: 0,0:57:20.24,0:57:36.10,Default,,0,0,0,,就比如string 啊、victor 它都没用，所以说它的可自定制性是很高的，甚至就是它的命名空间就平时不是都是FMTformat
Dialogue: 0,0:57:36.43,0:57:41.00,Default,,0,0,0,,他甚至这个前面repair the jason ，你也可以改
Dialogue: 0,0:57:41.00,0:57:50.15,Default,,0,0,0,,比如改成they know the pen 的坚持，或者they know a repair 的坚持，它都可以改，就定制性很高
Dialogue: 0,0:57:50.15,0:58:10.77,Default,,0,0,0,,然后呢，如果你知道 C++ 200的话，它里面有四大件，其中之一是range ，它的作用就相当于是python 这个东西它就相当于有这些东西
Dialogue: 0,0:58:10.77,0:58:21.13,Default,,0,0,0,,就比如我需要在for love 里面再获取一下它的这个下标，就要用到a numerate 这个这个函数嘛
Dialogue: 0,0:58:21.13,0:58:31.48,Default,,0,0,0,,然后这些东西居然是在标准库里一开始没有的，后来在20才开始陆续的加一些进来
Dialogue: 0,0:58:31.48,0:58:35.22,Default,,0,0,0,,然后最有用的annually 的还是没有
Dialogue: 0,0:58:35.22,0:58:49.89,Default,,0,0,0,,然后你去看就是 C++ 20的这样就是库它其实是对标这个东西呢，它就是吸收式认知为三，这个空的是不是挺不要脸的
Dialogue: 0,0:58:49.89,0:59:06.54,Default,,0,0,0,,其实 C++ 标准很多都是吸收至第三方库，比如智能指针就是来自boost 的H实现了逻辑
Dialogue: 0,0:59:07.37,0:59:24.98,Default,,0,0,0,,你的弹幕没了，可能是你涉及了一些屏蔽，就是B站着把你屏蔽掉，然后我也搜不到H中只有声明啊，H是没有实现的
Dialogue: 0,0:59:24.98,0:59:33.30,Default,,0,0,0,,实现是在CPP里实现的，FMT, 这个是很实用的
Dialogue: 0,0:59:33.30,0:59:39.35,Default,,0,0,0,,然后他也被无耻的 C++ 标准会给引入了
Dialogue: 0,0:59:39.35,0:59:59.04,Default,,0,0,0,,但是他这个STDformat 甚至没有它好用，就像 C++ 20的论据是库也缺很多功能，是它这个论据是V3都有的标准库里它就缺，比如ZIP这种很实用的东西，它就圈
Dialogue: 0,0:59:59.04,1:00:05.23,Default,,0,0,0,,然后这个方面它也是它其实比ST0方面它更好用
Dialogue: 0,1:00:05.56,1:00:12.33,Default,,0,0,0,,丢失比如有一个胶印之类的功能，然后它的用法就是
Dialogue: 0,1:00:23.00,1:00:37.09,Default,,0,0,0,,它的用法就很像那个python 方面，它可以用这个来表示要把四二这个数格式化到这里，就相当于变成这个了
Dialogue: 0,1:00:37.09,1:00:44.65,Default,,0,0,0,,就是他返回的呢是一个标准库的这个string 类型
Dialogue: 0,1:00:45.09,1:00:49.39,Default,,0,0,0,,然后他还有很多标准库没有的东西
Dialogue: 0,1:00:49.39,1:01:05.01,Default,,0,0,0,,就比如我有一个victory of string ，然后我就可以用这个后面他join XS
Dialogue: 0,1:01:09.29,1:01:39.98,Default,,0,0,0,,总之就是总之就是他可以把XX给就类似于那个东西，就是比如XS0 ，然后空格，然后XS一这个空格就是它可以自动帮你在每个元素之间插一个空格，你可以去它的官方文档去看看更多的知识，我就不看了
Dialogue: 0,1:01:39.98,1:01:42.69,Default,,0,0,0,,因为是介绍c max 嘛
Dialogue: 0,1:01:49.59,1:02:08.93,Default,,0,0,0,,然后他组阿科组啊，阿科组初中开始学C语言了，是不很不方便啊，主要是他这个没有包管理器就很烦
Dialogue: 0,1:02:09.26,1:02:18.74,Default,,0,0,0,,然后这个SPDlog 是一个它的坑点就在于它和format 是冲突的
Dialogue: 0,1:02:18.74,1:02:26.52,Default,,0,0,0,,因为它内置了一个format ，因为它日志输出也是基于format a format
Dialogue: 0,1:02:26.52,1:02:32.51,Default,,0,0,0,,如果你已经用的话，你就用不了这个SPDlog 了
Dialogue: 0,1:02:32.51,1:02:44.95,Default,,0,0,0,,就是你得用SPDlog 杠bundle 的杠方面的杠才能用，所以也不推荐这两个同时用
Dialogue: 0,1:02:44.95,1:03:00.04,Default,,0,0,0,,但是他们这种纯头文件就有个缺点，特别是这个它会导致变异变得很慢，因为它没有实现嘛，它实现得全部放在头文件里
Dialogue: 0,1:03:00.04,1:03:08.65,Default,,0,0,0,,就是我每编一个文件它都得重复去算一遍那个编译后的结果就很慢了
Dialogue: 0,1:03:08.65,1:03:12.66,Default,,0,0,0,,所以说更好的是作为子模块引入
Dialogue: 0,1:03:12.66,1:03:27.01,Default,,0,0,0,,然后我们今天来介绍一下GUM这个很好用的库，然后它甚至还有CMD的支持，它里面支持victory 啊、矩阵类啊都有
Dialogue: 0,1:03:27.01,1:03:33.72,Default,,0,0,0,,就是如果你找不到一个好用的数学库，你就是需要他
Dialogue: 0,1:03:35.16,1:03:50.82,Default,,0,0,0,,然后他这个VK3的构造函数也和那个澳门纪要的那个新的语言一样，可以指定三个餐桌啊啥的，然后也可以用V点XYZ
Dialogue: 0,1:03:50.82,1:03:59.26,Default,,0,0,0,,就是它不能用V点XYX这种语法不行，得定义一个红它才能支持
Dialogue: 0,1:03:59.59,1:04:03.72,Default,,0,0,0,,有问题吗？
Dialogue: 0,1:04:04.66,1:04:22.45,Default,,0,0,0,,代码提示啊代码提示代码提示用的是啊用的是you complete me
Dialogue: 0,1:04:22.45,1:04:37.97,Default,,0,0,0,,就是这个东西你可以去get hammer 上找这个链接，他们这个东西是集成了C两个编译器的，就是它会用CND去编译你的这个代码
Dialogue: 0,1:04:37.97,1:04:45.74,Default,,0,0,0,,它不是静态的分析，从而它能发现很多错误几乎和便利给的一样
Dialogue: 0,1:04:47.08,1:04:53.15,Default,,0,0,0,,那么屁呀啊这个你可以看一下这个叫什么
Dialogue: 0,1:04:54.20,1:05:09.75,Default,,0,0,0,,我的我的那个呢就是你可能不知道标准库里其实一直有这么一个东西，很多人都不知道有这个东西
Dialogue: 0,1:05:09.75,1:05:15.14,Default,,0,0,0,,然后它的类型其实和NOP的艾瑞是很像的
Dialogue: 0,1:05:15.47,1:05:28.16,Default,,0,0,0,,要是你可以定一个这个数这个这个数组，然后他们是有加法减法这种的，就看一个案例，看看有没有案例啊
Dialogue: 0,1:05:28.70,1:05:41.58,Default,,0,0,0,,就比如这样，我声明一个那个double 类型的war 宿主，然后可以把它们全部应用一下乘法，然后全部应用一下
Dialogue: 0,1:05:41.58,1:06:04.09,Default,,0,0,0,,散弹数是不是很神奇，标准库里竟然是有这个函数这个类的，然后很多人都不知道一样快都是那个汇编也能有什么区别呢，对吧？
Dialogue: 0,1:06:04.43,1:06:10.92,Default,,0,0,0,,然后可以看到他是把每个成了派，然后计算了扇子也是对的
Dialogue: 0,1:06:11.43,1:06:22.12,Default,,0,0,0,,是不是很神奇，这个哇艾瑞他什么时候引入的，他是什么时候？
Dialogue: 0,1:06:22.12,1:06:26.35,Default,,0,0,0,,他是 C++ 酒吧就有的东西耶
Dialogue: 0,1:06:26.68,1:06:41.79,Default,,0,0,0,,然后很多人还觉得就是为什么 C++ 没有，那么然后其实是有的，但是很多教程你都不会说，就很怪这么好用的东西
Dialogue: 0,1:06:42.71,1:06:47.81,Default,,0,0,0,,这个编译器自动会优化的，不需要你去操心
Dialogue: 0,1:06:47.81,1:06:59.66,Default,,0,0,0,,就是其实你自己去写一个for lop 编译器也是会去SMMD优化的UIM插件啊
Dialogue: 0,1:06:59.66,1:07:08.18,Default,,0,0,0,,你可以看我这里全部的插件，，你全部去下载一遍，然后就就行了
Dialogue: 0,1:07:08.18,1:07:20.79,Default,,0,0,0,,我的那个呢PPT，然后我们这里就用到了GOM用成了然后更好的一种方式
Dialogue: 0,1:07:20.79,1:07:24.96,Default,,0,0,0,,就是之前不是说format 编译很慢吗？
Dialogue: 0,1:07:24.96,1:07:41.20,Default,,0,0,0,,就是我们还可以作为子模块引入什么时间啊，我去已经三点子模块，也就是和我们刚才handle lab 一样的方式，把它的工程目录克隆下来
Dialogue: 0,1:07:41.20,1:07:47.69,Default,,0,0,0,,克隆也就是下载，然后下载到我们这个工程文件里
Dialogue: 0,1:07:47.69,1:07:57.39,Default,,0,0,0,,然后我们再艾特这个他的这个源码文件，然后我们就可以之后就可以用他这个库嘛
Dialogue: 0,1:07:57.39,1:08:07.10,Default,,0,0,0,,然后他刚才说了，这个也说了这个也说了，然后也说了ABS还有这个蛮有意思的
Dialogue: 0,1:08:07.10,1:08:19.31,Default,,0,0,0,,他其实是想要提供一些标准库没提供的，比如拍送都有的那种strength spring 传送，你可以去看一下他们官网
Dialogue: 0,1:08:19.31,1:08:27.93,Default,,0,0,0,,就如果你觉得 C++ 缺少这些拍摄常见的函数，它们其实都有
Dialogue: 0,1:08:28.63,1:08:35.92,Default,,0,0,0,,我这个也是记录在用的一个库，它可以实现这个赞回数
Dialogue: 0,1:08:35.92,1:08:42.31,Default,,0,0,0,,然后赞回数就是他会比如拍送这样的
Dialogue: 0,1:08:42.68,1:08:54.57,Default,,0,0,0,,and this volume is 就是trace back ，它会一行行说是哪个文件出错了，就很方便调试
Dialogue: 0,1:08:54.90,1:09:04.80,Default,,0,0,0,,然后谷歌测试就是单元测试，，然后性能评估这个我们之后会着重讲解
Dialogue: 0,1:09:04.80,1:09:12.32,Default,,0,0,0,,然后GOFW他们也是可以作为子模块的，太极就用了GLFW
Dialogue: 0,1:09:12.32,1:09:16.49,Default,,0,0,0,,然后HO是一个超大的库，变异超慢
Dialogue: 0,1:09:16.49,1:09:31.60,Default,,0,0,0,,但是它里面的算法很多也可以去了解一下哦，deep s 等于一就代表就代表他不会去得到这个项目的历史
Dialogue: 0,1:09:31.60,1:09:35.07,Default,,0,0,0,,就是我的get 项目，它是有历史的
Dialogue: 0,1:09:35.07,1:09:43.91,Default,,0,0,0,,就如果你不用deep s 1 ，它是允许你查看它上一个修改，之前的修改是长什么样的
Dialogue: 0,1:09:43.91,1:09:52.20,Default,,0,0,0,,但是D不是一等于一，它就不需要去查看，它就可以，只需要克隆最新的更改
Dialogue: 0,1:09:52.20,1:09:55.41,Default,,0,0,0,,然后这样克隆其实是更快的
Dialogue: 0,1:09:55.41,1:10:04.78,Default,,0,0,0,,我建议你们如果想不想要给这个项目做贡献的话，你就直接DF4等于一就可以了
Dialogue: 0,1:10:04.78,1:10:07.19,Default,,0,0,0,,它是克隆起来就更快
Dialogue: 0,1:10:07.86,1:10:20.00,Default,,0,0,0,,然后方面的使用刚才看过了，就是类似于拍摄的大括号语法，然后live IGO里面有C级AL的
Dialogue: 0,1:10:20.61,1:10:26.99,Default,,0,0,0,,就是我看看啊
Dialogue: 0,1:10:32.80,1:10:39.50,Default,,0,0,0,,然后就是这个东西它也能支持，比如像04D这样的格式
Dialogue: 0,1:10:40.74,1:10:59.65,Default,,0,0,0,,你看啊首先它会编译一下format ，然后可以看到这里已经格式化成04D的，这个是它和拍摄的语法是完全一样的
Dialogue: 0,1:11:00.40,1:11:13.08,Default,,0,0,0,,就是你知道live IGL它是包装了C级AL，就是你去掉IGL的一些几何算法库，它其实会去调用C级ALL
Dialogue: 0,1:11:15.00,1:11:20.31,Default,,0,0,0,,但是live IG1就把这个接口包装的更友好
Dialogue: 0,1:11:20.31,1:11:24.16,Default,,0,0,0,,比如他是用ign 作为参数broadcast
Dialogue: 0,1:11:24.16,1:11:36.85,Default,,0,0,0,,有的你刚看我刚刚的文档仔细看，然后C级AL它的那个接口是函数式的接口，就很烦人
Dialogue: 0,1:11:38.19,1:11:49.81,Default,,0,0,0,,所以IGO里面很多库都是分装了，别的库，他自己是大自然的搬运工，大概大概要四点了吧
Dialogue: 0,1:11:50.44,1:12:15.98,Default,,0,0,0,,然后然后是寻找系统中的库，就是说有三种方式，第一种头文件最好，然后子模块稍微要改一下CM，然后预安装，这个是最麻烦的一种，但它其实是解决很多问题，就比如作为子模块有一个什么很大的问题
Dialogue: 0,1:12:15.98,1:12:19.94,Default,,0,0,0,,就刚才提到SPD它依赖了format
Dialogue: 0,1:12:19.94,1:12:27.57,Default,,0,0,0,,而如果你的项目依赖了SPD，又依赖format，它就是一个菱形依赖
Dialogue: 0,1:12:27.57,1:12:30.68,Default,,0,0,0,,然后你就会出现两个format
Dialogue: 0,1:12:30.68,1:12:43.11,Default,,0,0,0,,这和刚刚我们include guard 是同一个问题，就是我用了方面，他也用了方面方面，他被定义了两遍，出错了
Dialogue: 0,1:12:43.86,1:12:49.09,Default,,0,0,0,,然后但是如果用系统预安装呢，就没这个问题
Dialogue: 0,1:12:49.09,1:12:55.43,Default,,0,0,0,,他在放的这个SPD的时候，他也会自动的去找到format
Dialogue: 0,1:12:55.43,1:13:05.35,Default,,0,0,0,,然后你之后再去找format 的时候， CMake 会查找缓存，缓存说已经找到format 了，那就不再找了
Dialogue: 0,1:13:05.35,1:13:14.73,Default,,0,0,0,,所以说作为系统中安装的库，它能够解决刚才和.h 同样的那个菱形依赖的问题
Dialogue: 0,1:13:16.89,1:13:26.09,Default,,0,0,0,,然后可以看到我们这里作为预安装以后变成format more，这是为啥呢？
Dialogue: 0,1:13:26.09,1:13:27.61,Default,,0,0,0,,我先喝口水
Dialogue: 0,1:13:32.70,1:13:42.91,Default,,0,0,0,,这是因为一个包，不是一个库 CMake 把包和库看成两个东西，库是比包更小的力度
Dialogue: 0,1:13:43.25,1:13:48.15,Default,,0,0,0,,酷又称为主键，官方叫做主键，我管它叫酷
Dialogue: 0,1:13:48.15,1:13:56.52,Default,,0,0,0,,然后TBB这个包里就有TBB，TBBmy lock , TBBmy lock proxy 这三个库
Dialogue: 0,1:13:56.85,1:14:15.06,Default,,0,0,0,,然后你分别可以使用TB云冒号，TBBTBB冒号，TBBMlock, 这样去链接不同的你需要的那个子库，然后你也可以在犯罪的时候指定你需要的是哪些指控
Dialogue: 0,1:14:15.06,1:14:34.89,Default,,0,0,0,,当然public 还是和之前一样，他们就是有一个点，就是如果你链接了这个open VDB，它也会把链接TBB就是open VDB链接以后，它会把TBB传染给你
Dialogue: 0,1:14:35.22,1:14:47.64,Default,,0,0,0,,然后他其实是当你输入饭的TBB的时候，他即使是去找了一下这个文件
Dialogue: 0,1:14:55.96,1:15:04.30,Default,,0,0,0,,他其实是在找这个文件，那这个文件你会去寻找user gun lab 的TVB
Dialogue: 0,1:15:04.86,1:15:14.80,Default,,0,0,0,,比如这个他就是在找level TBB点SO，然后level TBB点点bug
Dialogue: 0,1:15:14.80,1:15:34.42,Default,,0,0,0,,我是actually linux ，然后就是其他包，它也有各自的那个参数和格式，你可以看一下BLAS的这个引用参考格式
Dialogue: 0,1:15:34.42,1:15:39.59,Default,,0,0,0,,然后这些是区分大小写的，不要搞错了
Dialogue: 0,1:15:39.92,1:15:44.18,Default,,0,0,0,,搞错的话他还会找不到他是分大小写的
Dialogue: 0,1:15:44.76,1:15:49.35,Default,,0,0,0,,等待会儿再看吧
Dialogue: 0,1:15:49.35,1:15:58.72,Default,,0,0,0,,然后就是谈到包管理器的问题，我们知道 C++ 没有一个是官方的包管理器
Dialogue: 0,1:15:59.05,1:16:11.73,Default,,0,0,0,,但是在linux 上呢，他们都是用一个叫包管理器的东西，他们都是用这个来安装控的
Dialogue: 0,1:16:11.73,1:16:16.92,Default,,0,0,0,,就是如果你用windows 的话，是没有一个包管理器
Dialogue: 0,1:16:17.69,1:16:23.19,Default,,0,0,0,,就是比如这样我就可以安装format 这个库了
Dialogue: 0,1:16:23.19,1:16:32.97,Default,,0,0,0,,但是用windows 的话，它没有包管理器，就导致 C++ 好像就非常困难，就一次起来
Dialogue: 0,1:16:32.97,1:16:45.80,Default,,0,0,0,,而且不同的发行版它也用了不同的曝光仪器，像乌班图或用APT，而且他们安装的格式也不是这样
Dialogue: 0,1:16:45.80,1:16:56.19,Default,,0,0,0,,他们会前面加一个lab ，后面加一个DEV就必须这样才能安装到我想要的那种库
Dialogue: 0,1:16:56.19,1:17:11.88,Default,,0,0,0,,有不同的不同的包管理器，它的名字规范它都不一样，就导致非常困难啊，什么几岁我只记得初中呀，我咋记得几岁
Dialogue: 0,1:17:14.24,1:17:30.52,Default,,0,0,0,,然后微软为了解决windows 没有包管理器的问题，他们推出了VCPK级这个跨平台的，但是源码级的包管理器为什么说源码器呢？
Dialogue: 0,1:17:30.52,1:17:38.53,Default,,0,0,0,,就是当你是用linux 的这个，它是运行帮你编译好的，就是它会针对你的
Dialogue: 0,1:17:38.53,1:17:44.82,Default,,0,0,0,,比如某8664架构，他事先编译好下载给你就行了
Dialogue: 0,1:17:44.82,1:17:54.55,Default,,0,0,0,,而他这个不行，他会直接获取你的源码，然后从源码全部编译一遍，然后再给你按照
Dialogue: 0,1:17:55.00,1:18:03.51,Default,,0,0,0,,就比如对于boost 这种编译超级慢的库，它会需要很长时间才能安装成功
Dialogue: 0,1:18:03.51,1:18:16.11,Default,,0,0,0,,然后它的使用方式就是这一串先进入VCpackage , 然后初始化，然后安装VCpackage 的系统，然后安装format 库
Dialogue: 0,1:18:16.11,1:18:26.42,Default,,0,0,0,,然后安装完以后出来这个目录，然后我们在 CMake 上传的时候定义一下这个变量就完了
Dialogue: 0,1:18:26.42,1:18:42.10,Default,,0,0,0,,就是如果你已经生成过的话，记得先删一下view 的目录，，然后定义一下这个出签file ，等于他们这个日志日志超长的文件名就可以用了
Dialogue: 0,1:18:42.43,1:18:53.38,Default,,0,0,0,,总之他们这个东西我不是很看好，因为就是首先他没法指定这format 是什么版本
Dialogue: 0,1:18:53.38,1:19:00.02,Default,,0,0,0,,如果我想要就应用版本，它就不行，它还是给你最新的版本
Dialogue: 0,1:19:01.09,1:19:08.98,Default,,0,0,0,,然后就是他们有时候安装会出错，你得给他们提一个issue
Dialogue: 0,1:19:08.98,1:19:20.22,Default,,0,0,0,,你看1.1千1100个issue，各种标的L就他们这个东西经常会安装的，安装的就出错了
Dialogue: 0,1:19:20.22,1:19:25.96,Default,,0,0,0,,你得给他们提一个issue，也就是我们get home 上有issue 的功能
Dialogue: 0,1:19:25.96,1:19:38.99,Default,,0,0,0,,就是你说我的包出错了，你给他开一个艾灸说，哎呀，你能不能帮我修一下这个包啊，修完以后你再泡一下，它才能安装成功
Dialogue: 0,1:19:38.99,1:19:52.42,Default,,0,0,0,,就是这个东西他们维护的成本还蛮高的，就是他有时候会出错，我也不知道是为什么能从忘记吗？
Dialogue: 0,1:19:53.64,1:20:10.61,Default,,0,0,0,,看包的名字啊，看这个文件夹，看pots，看全是他们的包，你找一下，比如找我最爱的VDV，哎呀，还找不到太多了
Dialogue: 0,1:20:10.61,1:20:28.52,Default,,0,0,0,,总之就是他的包是在这里看，然后他这个因为太大get，他们都帮你省略掉一些，就有可能找不到这个东西，我也不是非常看好他们
Dialogue: 0,1:20:28.85,1:20:37.49,Default,,0,0,0,,然后感谢您的观看，然后之后我会把这个录屏文件上传到那个B站上
Dialogue: 0,1:20:37.49,1:20:40.66,Default,,0,0,0,,然后这是我的get up 的地址
Dialogue: 0,1:20:40.66,1:20:47.30,Default,,0,0,0,,然后这是我创建了一个组织，用来放我的PPT和代码
Dialogue: 0,1:20:50.47,1:20:53.09,Default,,0,0,0,,我看看录的怎么样了
